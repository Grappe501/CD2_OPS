/**
 * CD2_OPS — generate-form-api-access-map
 *
 * Reads Widget Registry + Route Map and generates:
 *   apps/web/src/lib/formApiAccessMap.generated.ts
 *
 * Design constraints:
 * - No TS runtime dependency (no ts-node/tsx). We parse with conservative regex.
 * - Enforces LOCKED RULE: api widgets must declare `accessRoute`.
 *
 * Usage:
 *   node scripts/generate-form-api-access-map.mjs --write
 *   node scripts/generate-form-api-access-map.mjs          (dry-run to stdout)
 */
import fs from "node:fs";
import path from "node:path";
import crypto from "node:crypto";

const ROOT = process.cwd();

const WIDGETS_PATH = path.join(ROOT, "packages/core/src/widgets.ts");
const ROUTE_MAP_PATH = path.join(ROOT, "apps/web/src/lib/routeMap.ts");
const OUT_PATH = path.join(ROOT, "apps/web/src/lib/formApiAccessMap.generated.ts");

function die(msg) {
  console.error("\n[gen:parity] ERROR:", msg);
  process.exit(1);
}

function fileOrDie(p) {
  if (!fs.existsSync(p)) die(`Missing required file: ${p}`);
  return fs.readFileSync(p, "utf-8");
}

// Extract all dashboard routes from routeMap.ts (best-effort).
function extractDashboardRoutes(routeMapText) {
  // Matches keys in DASHBOARD_ROUTE_ROLES: "/dashboard/xyz": [...]
  const re = /["'`](\/dashboard[^"'`]+)["'`]\s*:\s*\[/g;
  const out = new Set();
  let m;
  while ((m = re.exec(routeMapText))) out.add(m[1]);
  // Also include prefix keys that end with "/" (dynamic groupings)
  return out;
}

/**
 * Extract API widgets:
 * We search for patterns:
 *   path: "/api/forms/..."
 * and in same object block, require:
 *   accessRoute: "/dashboard/..."
 *
 * This is a conservative regex approach:
 * - Works if widgets are declared as plain objects in an array.
 * - If registry is refactored, add an explicit JSON export or a build-time script.
 */
function extractApiWidgetPairs(widgetsText) {
  // Rough object block matcher: { ... } with minimal nesting support
  // We'll instead scan around each "/api/forms/" occurrence.
  const apiRe = /\/api\/forms\/[a-zA-Z0-9\-_/]+/g;
  const pairs = []; // { apiPath, accessRoute }
  let m;

  while ((m = apiRe.exec(widgetsText))) {
    const apiPath = m[0];

    // Take a window around the match to find an accessRoute in same object.
    const start = Math.max(0, m.index - 600);
    const end = Math.min(widgetsText.length, m.index + 600);
    const window = widgetsText.slice(start, end);

    // Access route must exist near the api path
    const accRe = /accessRoute\s*:\s*["'`](\/dashboard[^"'`]+)["'`]/;
    const acc = window.match(accRe);
    if (!acc) {
      die(`API widget references "${apiPath}" but has no accessRoute nearby. Add accessRoute: "/dashboard/..." to that widget.`);
    }
    const accessRoute = acc[1];

    // Validate api path is under /api/forms
    if (!apiPath.startsWith("/api/forms/")) die(`Invalid api path: ${apiPath}`);

    pairs.push({ apiPath, accessRoute });
  }

  // Deduplicate (same apiPath may appear in multiple widgets; ensure consistent mapping)
  const map = new Map();
  for (const p of pairs) {
    if (!map.has(p.apiPath)) map.set(p.apiPath, p.accessRoute);
    else {
      const prev = map.get(p.apiPath);
      if (prev !== p.accessRoute) {
        die(`Conflicting accessRoute for ${p.apiPath}: "${prev}" vs "${p.accessRoute}". Fix widget registry.`);
      }
    }
  }
  return Array.from(map.entries()).map(([apiPath, accessRoute]) => ({ apiPath, accessRoute }));
}

function renderGenerated(mapObj) {
  const banner = `/**
 * AUTO-GENERATED FILE — DO NOT EDIT BY HAND
 * Generated by: scripts/generate-form-api-access-map.mjs
 *
 * Source of truth:
 * - packages/core/src/widgets.ts  (api widgets + accessRoute)
 * - apps/web/src/lib/routeMap.ts  (valid dashboard routes)
 */\n`;
  const body = `export const FORM_API_ACCESS_MAP: Record<string, string> = ${JSON.stringify(mapObj, null, 2)};\n\n` +
               `export function dashboardRouteForApiPath(apiPath: string): string | null {\n` +
               `  return FORM_API_ACCESS_MAP[apiPath] ?? null;\n` +
               `}\n`;
  return banner + body;
}

function sha(txt) {
  return crypto.createHash("sha256").update(txt).digest("hex");
}

const widgetsText = fileOrDie(WIDGETS_PATH);
const routeMapText = fileOrDie(ROUTE_MAP_PATH);

const validRoutes = extractDashboardRoutes(routeMapText);
const pairs = extractApiWidgetPairs(widgetsText);

// Validate all accessRoutes exist in routeMap
for (const p of pairs) {
  if (!validRoutes.has(p.accessRoute)) {
    die(`Widget maps ${p.apiPath} -> ${p.accessRoute}, but ${p.accessRoute} is not present in routeMap.ts DASHBOARD_ROUTE_ROLES. Add it or fix accessRoute.`);
  }
}

// Build map obj
const mapObj = {};
for (const p of pairs.sort((a,b) => a.apiPath.localeCompare(b.apiPath))) {
  mapObj[p.apiPath] = p.accessRoute;
}

const outText = renderGenerated(mapObj);

const args = new Set(process.argv.slice(2));
if (args.has("--write")) {
  fs.mkdirSync(path.dirname(OUT_PATH), { recursive: true });
  fs.writeFileSync(OUT_PATH, outText, "utf-8");
  console.log(`[gen:parity] wrote ${OUT_PATH} (${Object.keys(mapObj).length} mappings) sha=${sha(outText).slice(0,10)}`);
} else {
  process.stdout.write(outText);
}
